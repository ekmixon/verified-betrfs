 - Better module abstraction.
    - This works as long as you keep your chain of abstract modules
      linear, although it's a bit of a pain.
    - If you try to have a diamond
      of abstract module inclusions, everything falls apart because you have
      no way to specify that the two inclusions of the same abstract module
      are the same.

- Better state machine abstraction.
    - State machine refinement is not the same as Dafny module refinement.
      If I build state machine X using state machine Y as a subcomponent,
      and then I create refinement Y' of Y, I can't automatically get an X'
      which has Y replaced with Y'. Instead I have to write a lot of boilerplate.

- Better way to specify implemenation vs spec files with including files.

- Sequence comprehension syntax

- Type aliasing is a bit broken.
    - type foo = parent.bar
    - diamond problem -- sometimes Dafny can't see type equivalence where we expect it
    - if parent.bar is a datatype, its constructors aren't aliased in at foo.

- It seems like a bug that Dafny lets you mention a generic type in a parameter list without
    mentioning the <actual types>

- How do we program generically over algebraic datatypes? Would like to
    have a datatype with an associated < method. We see the (==) trait,
    but ... how do we write our own?

- current code uses 'type' abstraction for Values; it will require lots
    of code to instantiate the Betree for specific Values.
    Prior code used <>-generics for Values, which was wordy and gross
    in a different way.
    Rob wants the best of both worlds.
    
- non-stupid implementation of sequences

- include-root

- better error messages
  - output line itself in addition to line numbers
  - anon wtf?

- auto-cast uint64 to ints
- methods on datatypes (because we don't necessarily want to use a class)

- d6d75b81577205ab31aafa4761a97a9b6ef72d1e timeout/instability with no smoking guns in the profiler
- 1a88431e5c4ec22082a390f894878e10b2009a5f see Probe in MutableMap:449 for fix, surprising assert required

{:axiom} shouldn't be required on a bodyless function of an abstract module
which is there to introduce an obligation, should it?
    ../disk-betree/MapSpec.s.dfy(2,8): Error: the included file ../disk-betree/../lib/total_order.s.dfy contains error(s)
    ../disk-betree/../lib/total_order.s.dfy(21,73): Error: a function with an ensures clause must have a body, unless given the :axiom attribute

- [NOALIAS]
  - examples where statically enforced no-aliasing would help
    - f03fb540e4fd8e9fa7e04192fbe45120d2beeaa3 (noalias-example-00) disk-betree/MainImpl.i.dfy:73
    - ccc3169011232da48d814b8ee1662bf36e4ca198 (noalias-example-01) disk-betree/ImplDo.i.dfy:344 disk-betree/ImplState.i.dfy:100
    - a5323d0aaa5793cb2b3632ceb5c43e0fccbc66db (noalias-example-02) disk-betree/ImplSync.i.dfy:303 and following lines, :159 and following lines
    - 759c0889f4ca49cbdf6d44f27509baa3fdd7f6d3 disk-betree/ImplMarshalling.i.dfy:677 and following

- Rob's profiler didn't help here: 88b8873f549dff64fa7cb5f853aa636591a8aaae (profile-useless-00) for disk-betree/ImplSync.i.dfy::doSplit
  - `mono ~/VMware/dafny-base/dafny/Binaries/Dafny.exe ImplSync.i.dfy  /compile:0 /proc:'*doSplit*' /timeLimit:120 /z3opt:smt.qi.profile=true /z3opt:smt.qi.profile_freq=1000 > /tmp/dafny.profile`

warnings about unused non-ghost variables
warnings about if/forall statements where condition is non-ghost but body is entirely ghost
ghost { } blocks
