include "MarshalledAccessors.i.dfy"
include "../Base/sequences.i.dfy"

abstract module Tuple{{count}}Marshalling refines Marshalling {
  import TableMarshalling : IntegerSeqMarshalling
  import Sequences
  import BoundaryInt = TableMarshalling.Int

{%- for n in range(0,count) %}
  import ElemMarshalling{{n}} : Marshalling
{%- endfor %}

  type Boundary = BoundaryInt.Integer
  type BoundaryTable = mseq<Boundary>

  type UnmarshalledType = (
{%- for n in range(0,count) %}
    {%- if n != count - 1 -%}
        ElemMarshalling{{n}}.UnmarshalledType, 
    {% else -%}
        ElemMarshalling{{n}}.UnmarshalledType)
    {% endif %}
{%- endfor %}

  function method SizeOfBoundaryEntry() : uint64
  {
    BoundaryInt.Size()
  }

  function method sizeOfTable() : nat
  {
    {{count-1}} * SizeOfBoundaryEntry() as nat
  }

  predicate parsable(data: mseq<byte>)
  {
    && var tableSize := sizeOfTable();
    && SizeOfBoundaryEntry() as int < Uint64UpperBound() / {{count-1}}
    && |data| >= tableSize
    && TableMarshalling.parsable(data[..tableSize])
    && var table :mseq<Boundary> := TableMarshalling.parse(data[..tableSize]);
{% for n in range(0,count) %}
    {% if n == 0 -%}
    && var bound0 := BoundaryInt.toInt(table[0]);
    && tableSize <= bound0 <= |data|
    && ElemMarshalling0.parsable(data[tableSize..bound0])
    {% elif n != count-1 -%}
    && var bound{{n}} := BoundaryInt.toInt(table[{{n}}]);
    && bound{{n-1}} <= bound{{n}} <= |data|
    && ElemMarshalling{{n}}.parsable(data[bound{{n-1}}..bound{{n}}])
    {% else -%}
    && ElemMarshalling{{n}}.parsable(data[bound{{n-1}}..])
    {% endif -%}
{% endfor %}
  }

  function parse(data: mseq<byte>) : UnmarshalledType
  {
    var tableSize := sizeOfTable();
    var table :mseq<Boundary> := TableMarshalling.parse(data[..tableSize]);
{% for n in range(0,count) %}
    {% if n == 0 -%}
    var bound0 := BoundaryInt.toInt(table[0]);
    var elem0 := ElemMarshalling0.parse(data[tableSize..bound0]);
    {% elif n != count-1 -%}
    var bound{{n}} := BoundaryInt.toInt(table[{{n}}]);
    var elem{{n}} := ElemMarshalling{{n}}.parse(data[bound{{n-1}}..bound{{n}}]);
    {% else -%}
    var elem{{n}} := ElemMarshalling{{n}}.parse(data[bound{{n-1}}..]);
    {% endif -%}
{% endfor %}
    (
{%- for n in range(0,count) -%}
    {%- if n != count - 1 -%}
      elem{{n}},
    {% else -%}
      elem{{n}})
    {%- endif %}
{%- endfor %}
  }

  method TryParse(data: mseq<byte>) returns (ovalue: Option<UnmarshalledType>)
  {
    var entrySize := SizeOfBoundaryEntry();
{% if count > 2 %}
    if entrySize >= {{esize}} {
      return None;
    }
{% endif %}
    var tableSize := entrySize * {{count-1}};

    if tableSize > |data| as uint64 {
      return None;
    }

    var tableOpt := TableMarshalling.TryParse(data[..tableSize]);
    
    if tableOpt.None? {
      return None;
    }

    var table :mseq<Boundary> := tableOpt.value;
  
    if {%+ for n in range(0,count-1) -%}
      || !BoundaryInt.fitsInUint64(table[{{n}}])
    {% endfor -%} {
      return None;
    }
{% for n in range(0,count-1) %}
    var bound{{n}} := BoundaryInt.toUint64(table[{{n}}]);
{%- endfor %}

{% for n in range(0,count-1) %}
    {%- if n == 0 %}
    if bound0 > |data| as uint64 || bound0 < tableSize {
      return None;
    }
    {%- else %}
    if bound{{n}} > |data| as uint64 || bound{{n}} < bound{{n-1}} {
      return None;
    }
    {% endif %}
{% endfor -%}

{% for n in range(0,count) %}
    {%- if n == 0 %}
    var elemOpt0 := ElemMarshalling0.TryParse(data[tableSize..bound0]);
    {%- elif n != count - 1 %}
    var elemOpt{{n}} := ElemMarshalling{{n}}.TryParse(data[bound{{n-1}}..bound{{n}}]);
    {%- else %}
    var elemOpt{{n}} := ElemMarshalling{{n}}.TryParse(data[bound{{n-1}}..]);
    {% endif %}
{%- endfor %}
    if {%+ for n in range(0,count) -%}
      || elemOpt{{n}}.None?
    {% endfor -%} {
      return None;
    }

    return Some((
    {%- for n in range(0,count) -%}
    {%- if n != count - 1 -%}
      elemOpt{{n}}.value,
    {% else -%}
      elemOpt{{n}}.value));
    {%- endif %}
    {%- endfor %}
  }

  method Parsable(data: mseq<byte>) returns (p: bool)
  {
    var entrySize := SizeOfBoundaryEntry();
{% if count > 2 %}
    if entrySize >= {{esize}} {
      return false;
    }
{% endif %}
    var tableSize := entrySize * {{count-1}};

    if tableSize > |data| as uint64 {
      return false;
    }

    var tableOpt := TableMarshalling.TryParse(data[..tableSize]);
    
    if tableOpt.None? {
      return false;
    }

    var table :mseq<Boundary> := tableOpt.value;
  
    if {%+ for n in range(0,count-1) -%}
      || !BoundaryInt.fitsInUint64(table[{{n}}])
    {% endfor -%} {
      return false;
    }
{% for n in range(0,count-1) %}
    var bound{{n}} := BoundaryInt.toUint64(table[{{n}}]);
{%- endfor %}

{% for n in range(0,count-1) %}
    {%- if n == 0 %}
    if bound0 > |data| as uint64 || bound0 < tableSize {
      return false;
    }
    {%- else %}
    if bound{{n}} > |data| as uint64 || bound{{n}} < bound{{n-1}} {
      return false;
    }
    {% endif %}
{% endfor -%}

{% for n in range(0,count) %}
    {%- if n == 0 %}
    var elemParsable0 := ElemMarshalling0.Parsable(data[tableSize..bound0]);
    {%- elif n != count - 1 %}
    var elemParsable{{n}} := ElemMarshalling{{n}}.Parsable(data[bound{{n-1}}..bound{{n}}]);
    {%- else %}
    var elemParsable{{n}} := ElemMarshalling{{n}}.Parsable(data[bound{{n-1}}..]);
    {% endif %}
{%- endfor %}
    if {%+ for n in range(0,count) -%}
      || !elemParsable{{n}}
    {% endfor -%} {
      return false;
    }

    return true;
  }

  method Parse(data: mseq<byte>) returns (value: UnmarshalledType)
  {
    var tableSize := sizeOfTable() as uint64;
    var table :mseq<Boundary> := TableMarshalling.Parse(data[..tableSize]);
{% for n in range(0,count-1) %}
    var bound{{n}} := BoundaryInt.toUint64(table[{{n}}]);
{%- endfor %}
{% for n in range(0,count) %}
    {%- if n == 0 %}
    var elem0 := ElemMarshalling0.Parse(data[tableSize..bound0]);
    {%- elif n != count - 1 %}
    var elem{{n}} := ElemMarshalling{{n}}.Parse(data[bound{{n-1}}..bound{{n}}]);
    {%- else %}
    var elem{{n}} := ElemMarshalling{{n}}.Parse(data[bound{{n-1}}..]);
    {% endif %}
{%- endfor %}
    return (
    {%- for n in range(0,count) -%}
    {%- if n != count - 1 -%}
      elem{{n}},
    {% else -%}
      elem{{n}});
    {%- endif %}
    {%- endfor %}
  }

  predicate marshallable(value: UnmarshalledType)
  {
    && var entrySize := SizeOfBoundaryEntry();
{% if count > 2 %}
    && entrySize < {{esize}}
{% endif %}
    && var ({%- for n in range(0,count) -%}
    {%- if n != count - 1 -%}
      elem{{n}},
    {%- else -%}
      elem{{n}}) := value;
    {%- endif %}
    {%- endfor %}
{%- for n in range(0,count) %}
    && ElemMarshalling{{n}}.marshallable(elem{{n}})
{%- endfor %}
{% for n in range(0,count-1) %}
    {%- if n == 0 %}
    && var tableSize := sizeOfTable();
    var size0 := ElemMarshalling0.size(elem0);
    var bound0 := tableSize + size0;
    {%- else %}
    var size{{n}} := ElemMarshalling{{n}}.size(elem{{n}});
    var bound{{n}} := bound{{n-1}} + size{{n}};
    {% endif %}
{%- endfor %}
{%- for n in range(0,count-1) %}
    && BoundaryInt.MinValue() <= bound{{n}} < BoundaryInt.UpperBound()
{%- endfor %}
    && var table := [
{%- for n in range(0,count-1) -%}
    {%- if n != count-2 -%}
      BoundaryInt.fromInt(bound{{n}}),
    {% else -%}
      BoundaryInt.fromInt(bound{{n}})];
    {%- endif %}
{%- endfor %}
    && TableMarshalling.marshallable(table)
  }

  function size(value: UnmarshalledType) : nat
  {
    var ({%- for n in range(0,count) -%}
    {%- if n != count - 1 -%}
      elem{{n}},
    {%- else -%}
      elem{{n}}) := value;
    {%- endif %}
    {%- endfor %}
    var tableSize := sizeOfTable();
{%- for n in range(0,count) %}
    var size{{n}} := ElemMarshalling{{n}}.size(elem{{n}});
{%- endfor %}

    tableSize+{% for n in range(0,count) -%}
  {%- if n != count - 1 -%}
      size{{n}}+ 
  {%- else -%}
      size{{n}}
  {%- endif %}
{%- endfor %}
  }

  method Size(value: UnmarshalledType) returns (sz: uint64)
  {
    var ({%- for n in range(0,count) -%}
    {%- if n != count - 1 -%}
      elem{{n}},
    {%- else -%}
      elem{{n}}) := value;
    {%- endif %}
    {%- endfor %}
    var tableSize := sizeOfTable() as uint64;
{%- for n in range(0,count) %}
    var size{{n}} := ElemMarshalling{{n}}.Size(elem{{n}});
{%- endfor %}

    sz := tableSize+{% for n in range(0,count) -%}
  {%- if n != count - 1 -%}
      size{{n}}+ 
  {%- else -%}
      size{{n}};
  {%- endif %}
{%- endfor %}
  }

  method Marshall(value: UnmarshalledType, linear data: mseq<byte>, start: uint64)
    returns (linear newdata: mseq<byte>, end: uint64)
  {
    var ({%- for n in range(0,count) -%}
    {%- if n != count - 1 -%}
      elem{{n}},
    {%- else -%}
      elem{{n}}) := value;
    {%- endif %}
    {%- endfor %}
{% for n in range(0,count-1) %}
    {%- if n == 0 %}
    var tableSize := sizeOfTable() as uint64;
    var size0 := ElemMarshalling0.Size(elem0);
    var bound0 := tableSize + size0;
    {%- else %}
    var size{{n}} := ElemMarshalling{{n}}.Size(elem{{n}});
    var bound{{n}} := bound{{n-1}} + size{{n}};
    {% endif %}
{%- endfor %}
    var table := [
{%- for n in range(0,count-1) -%}
    {%- if n != count-2 -%}
      BoundaryInt.fromUint64(bound{{n}}),
    {% else -%}
      BoundaryInt.fromUint64(bound{{n}})];
    {%- endif %}
{%- endfor %}

    {% for n in range(0,count+1) -%}
    {% if n == 0 -%}
    newdata, end := TableMarshalling.Marshall(table, data, start);
    ghost var newdata0 :seq<byte>, end0 := newdata, end;
    {% elif n != count -%}
    newdata, end := ElemMarshalling{{n-1}}.Marshall(elem{{n-1}}, newdata, end);
    ghost var newdata{{n}} :seq<byte>, end{{n}} := newdata, end;
    {% else -%}
    newdata, end := ElemMarshalling{{n-1}}.Marshall(elem{{n-1}}, newdata, end);
    {%- endif %}
{%- endfor %}

    assert {% for n in range(0,count-1) %}
      && BoundaryInt.toInt(table[{{n}}]) == bound{{n}} as int 
    {%- endfor %} by {
      BoundaryInt.fromtoInverses();
    }

    assert newdata[start..end][..tableSize] == newdata[start..end0] == newdata0[start..end0];
    // assert TableMarshalling.parse(newdata[start..end0]) == table;
    
    assert newdata[start..end][tableSize..bound0] == newdata[end0..end1] == newdata1[end0..end1] by {
      Sequences.lemma_seq_slice_slice(newdata, start as int, end as int, tableSize as int, bound0 as int);
    }
    // assert ElemMarshalling0.parse(newdata[end0..end1]) == elem0;

{% for n in range(1,count-1) %}
    assert newdata[start..end][bound{{n-1}}..bound{{n}}] == newdata[end{{n}}..end{{n+1}}] == newdata{{n+1}}[end{{n}}..end{{n+1}}] by {
      Sequences.lemma_seq_slice_slice(newdata, start as int, end as int, bound{{n-1}} as int, bound{{n}} as int);
    }
    // assert ElemMarshalling{{n}}.parse(newdata[end{{n}}..end{{n+1}}]) == elem{{n}};
{%- endfor %}

    assert newdata[start..end][bound{{count-2}}..] == newdata[end{{count-1}}..end];
    // assert ElemMarshalling{{count-1}}.parse(newdata[end{{count-1}}..end]) == elem{{count-1}};
  }

  predicate gettable(data: mseq<byte>, index: nat)
  {
    && index <= {{count-1}}
    && SizeOfBoundaryEntry() < 0x8000_0000_0000_0000
    && var tableSize := sizeOfTable();
    && tableSize < Uint64UpperBound()
    && |data| >= tableSize
    && TableMarshalling.parsable(data[..tableSize])
    && var table :mseq<Boundary> := TableMarshalling.parse(data[..tableSize]);
    && var start := if index == 0 then tableSize else BoundaryInt.toInt(table[index - 1]);
    && var end := if index == {{count-1}} then |data| else BoundaryInt.toInt(table[index]);
    && 0 <= start <= end <= |data|
  }
{% for n in range(0,count) %}
  method GetElem{{n}}(data: mseq<byte>) returns (edata: mseq<byte>)
    requires parsable(data)
    ensures parsable(data) ==> ElemMarshalling{{n}}.parsable(edata)
    ensures parsable(data) ==> ElemMarshalling{{n}}.parse(edata) == parse(data).{{n}}
  {
    var tableSize := sizeOfTable() as uint64;
  {% if n == 0 %}
    var iend0 := TableMarshalling.FastGet(data[..tableSize], 0);
    var end0 := BoundaryInt.toUint64(iend0);
    edata := data[tableSize..end0];
  }
  {% elif n != count-1 %}
    var iend{{n-1}} := TableMarshalling.FastGet(data[..tableSize], {{n-1}});
    var end{{n-1}} := BoundaryInt.toUint64(iend{{n-1}});
    var iend{{n}} := TableMarshalling.FastGet(data[..tableSize], {{n}});
    var end{{n}} := BoundaryInt.toUint64(iend{{n}});

    edata := data[end{{n-1}}..end{{n}}];
  }
  {% else %}
    var iend{{n-1}} := TableMarshalling.FastGet(data[..tableSize], {{n-1}});
    var end{{n-1}} := BoundaryInt.toUint64(iend{{n-1}});
    edata := data[end{{n-1}}..];
  }
  {% endif -%}
{%- endfor %}
}